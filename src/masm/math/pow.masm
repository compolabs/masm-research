
# power func in progress

const.MAX_POSITIVE_INT=9223372034707292160
const.MAX_VAL=18446744069414584320

const.ONE=1000000
const.TWO=2000000

proc.to_negative
  push.MAX_VAL
  swap
  sub
end

proc.from_negative
  push.MAX_VAL
  swap 
  sub
end

# [b, a]
proc.signed_add

  # must check for overflow 
  dup
  # [b, b, a]

  push.MAX_VAL
  # [max_val, b, b, a]
  
  swap
  # [b, max_val, b, a]

  sub
  # [diff, b, a]

  swap.2
  # [a, b, diff]

  dup
  # [a, a, b, diff]

  swap.2
  # [b, a, a, diff]

  swap.3
  # [diff, a, a, b]

  gt
  #[overflow_bool, a, b]

  if.true
    add
    add.1
  else
    add
  end
end

proc.signed_sub
  swap
  # check for overflow / underflow
  dup
  # [b, b, a]

  push.MAX_VAL
  # [max_val, b, b, a]

  swap
  # [b, max_val, b, a]

  sub
  # [diff, b, a]

  swap.2
  # [a, b, diff]

  dup
  # [a, a, b, diff]

  swap.2
  # [b, a, a, diff]

  swap.3
  # [diff, a, a, b]

  gt
  #[overflow_bool, a, b]

  if.true
    dup.1
    dup.1
    lt
    if.true
      sub
      sub.1
    else
      sub
    end

  else
    dup.1
    dup.1
    lt 
    if.true
      sub
      sub.1  
    else 
      sub
    end

  end

end 

# uses memory addresses 0 & 1
proc.signed_mul
  dup.1 dup.1
  # [b, a, b, a]

  push.MAX_POSITIVE_INT
  # [max_pos, b, a, b, a]

  gt 
  # [bool, a, b, a]

  swap.4 drop
  # [a, b, a, bool]

  push.MAX_POSITIVE_INT
  # [max_pos, a, b, a, bool]

  gt

  swap.4 drop
  # [a, b, bool, bool]

  swap.4 drop
  swap.4 drop
  swap
  # [bool_a, bool_b, b, a]

  dup.1
  dup.1

  mem_store.0
  mem_store.1
  # [bool_a, bool_b, b, a]

  swap
  # [bool_b, bool_a, b, a]
  
  if.true
    swap
    exec.from_negative
  else
    swap
    # [b, bool_a, a]
  end

  swap
  # [bool_a, b, a]

  if.true
    swap
    exec.from_negative
  else
    swap
    # [a, b]
  end

  # [a, b]
  mul

  mem_load.1
  mem_load.0
  # [bool_a, bool_b, prod]
  
  xor
  # [xor, prod]

  if.true
    exec.to_negative
  else
    # nothing
  end

end


# uses memory addresses 0 & 1
proc.signed_div

  dup.1 dup.1
  # [b, a, b, a]

  push.MAX_POSITIVE_INT
  # [max_pos, b, a, b, a]

  gt 
  # [bool, a, b, a]

  swap.4 drop
  # [a, b, a, bool]

  push.MAX_POSITIVE_INT
  # [max_pos, a, b, a, bool]

  gt

  swap.4 drop
  # [a, b, bool, bool]

  swap.4 drop
  swap.4 drop
  swap
  # [bool_a, bool_b, b, a]

  dup.1
  dup.1

  mem_store.0
  mem_store.1
  # [bool_a, bool_b, b, a]

  swap
  # [bool_b, bool_a, b, a]
  
  if.true
    swap
    exec.from_negative
  else
    swap
    # [b, bool_a, a]
  end

  swap
  # [bool_a, b, a]

  if.true
    swap
    exec.from_negative
  else
    swap
    # [a, b]
  end

  # [a, b]
  u32div
  # div

  mem_load.1
  mem_load.0
  # [bool_a, bool_b, prod]
  
  xor
  # [xor, prod]

  if.true
    exec.to_negative
  else
    # nothing
  end

end


# floor div by 2
# a / 2^b = c
proc.shr
  push.1
  u32shr
end

# is 1e6 base number odd
# using memory addresses 10 & 11
proc.is_odd
  dup
  mem_store.10
  push.1000000
  # x % 1e6
  u32mod
  swap
  gt
  if.true
    # x % 1e6 > 0
    push.1
    mem_store.11
  else
    # check if x / 1e6 % 2 == 0
    mem_load.10
    div.1000000
    push.2
    u32mod
    if.true
      # x % 2 != 0
      push.1
      mem_store.11
    else
    end
  end
  # return memory address 11
  mem_load.11
end

# assumes 1e6 base
# [b, a]
proc.UD14x6_mul
  u32div.1000
  swap
  u32div.1000
  swap
  mul
end

# assumes 1e6 base
# [b, a]
proc.UD14x6_div
  div.1000
  u32div
  mul.1000
end

# a^b
# [b, a]
proc.pow
  # memory layout
  # 0 => base
  # 1 => exponent
  # 2 => result
  mem_store.0
  mem_store.1

  push.1000000 # result = 1
  mem_store.2

  ##### BEGIN CYCLE ######
  mem_load.1
  exec.is_odd

  # if exponent % 2 == 1
  if.true
    mem_load.0
    mem_load.2
    exec.UD14x6_mul
    mem_store.2 # result *= base

  else
    # nothing
  end
    
  mem_load.0
  dup
  exec.UD14x6_mul

  mem_store.0 # base *= base

  mem_load.1
  exec.shr # exponent //= 2 (floor div)
  mem_store.1
  ##### END CYCLE ######

  mem_load.1
  mem_load.2


  add
end

# 

# Taylor Series Expansion
# ln(1 + x) = x - x^2/2 + x^3/3 - x^4/4 + ...
proc.log
  mem_store.0 # save x to mem addr 0
  push.ONE

  # x - 1
  mem_load.0
  swap
  # [1e6, x]
  exec.signed_sub
  mem_store.1

  # x + 1
  mem_load.0
  push.ONE
  add # x can't be negative

  mem_store.2

  mem_load.1
  mem_load.2

  exec.UD14x6_div

  # y = (x - 1) / (x + 1)

  dup dup

  mem_store.1 # summation
  mem_store.2 # term

  # [y]
  dup
  exec.UD14x6_mul

  debug.stack

  # [y*y]
  mem_store.3 # y2

  # []

  push.ONE
  mem_store.4 # COUNTER

  # []

  repeat.2
    mem_load.2 # term
    mem_load.3 # y2

    debug.stack

    # 
    exec.UD14x6_mul

    dup
    mem_store.2 # store term *= y2

    mem_load.4 # counter
    push.2000000 # 2
    add # counter + 2

    exec.UD14x6_div

    mem_load.1
    add # summation += term / (counter + 2)

    mem_store.1

    # increment counter
    #mem_load.4
    #push.TWO
    #add
    # mem_store.4
    
  end

  # 2 * summation
  mem_load.1
  push.TWO
  exec.UD14x6_mul

  # debug.stack

  # exec.to_negative

end


begin
  dropw dropw dropw dropw

  # push.8000000
  # exec.is_odd_1e6

  # push.3000000.4250000
  # push.2000000.3000000
  # [b, a]
  # [3, 5]

  # debug.stack
  #exec.pow

  # push.17
  #exec.log2

  # push.11
  # exec.is_odd

  #exec.shr

  # push.300000.250000
  # exec.UD14x6_mul

  #debug.stack
  #exec.UD14x6_div

  # push.2000000
  push.2000000
  exec.log
  #exec.UD14x6_div





end